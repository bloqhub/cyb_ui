import React, {    useContext,    useEffect,    useState,} from 'react';import { connect } from 'react-redux';import { useLocation, useHistory, Route } from 'react-router-dom';import { Pane } from '@cybercongress/gravity';import BigNumber from 'bignumber.js';import queryString from 'query-string';import { AppContext } from '../../context';import { CYBER, DEFAULT_GAS_LIMITS, WARP_CONTRACTS } from '../../utils/config';import useSetActiveAddress from '../../hooks/useSetActiveAddress';import txs from '../../utils/txs';import { getPin, getPinsCid, getIpfsGatway, getTxs } from '../../utils/search/utils';import { GasPrice } from '@cosmjs/launchpad';import { Dots, ValueImg, ButtonIcon } from '../../components';import ItemsList from './components/tokens/items_list';import AddItemForm from './components/tokens/items_add';import EditItemForm from './components/tokens/items_edit';import styles from './warp.scss';function WarpTokens({ defaultAccount, ipfs, pushIpfsImage, statusChecker, onSelectLogo}) {    const { jsCyber, keplr } = useContext(AppContext);    const location = useLocation();    const history = useHistory();    const { addressActive } = useSetActiveAddress(defaultAccount);    const [update, setUpdate] = useState(0);    const [editing, setEditing] = useState(false);    const [creating, setCreating] = useState(false);    const [contractData, setContractData] = useState([]);    const [networks, setNetworks] = useState([]);    const loadNetworksData = (jsCyber, offset) => {        const data = jsCyber.queryContractSmart(            WARP_CONTRACTS.NETWORKS,            {                "get_items": {}            }        );        data.then((result) => {            setNetworks(result.entries);        });    };    const loadContractData = (jsCyber, offset) => {        const data = jsCyber.queryContractSmart(            WARP_CONTRACTS.TOKENS,            {                "get_items": {}            }        );        data.then((result) => {            setContractData(result.entries);        });    };    const getItems = (offset) => {        useEffect(() => {            if (jsCyber === null) {                return;            }            loadContractData(jsCyber);        }, [jsCyber]);        return { contractData };    };    useEffect(() => {        window.scrollTo({top: 0, left: 0, behavior: 'smooth'});    }, [creating, editing]);    const deleteRow = async (id) => {        return new Promise(async (accept, reject) => {            try {                const gasPrice = GasPrice.fromString('0.001boot');                const [{ address }] = await keplr.signer.getAccounts();                const outgoinxTxData = await keplr.execute(                    address,                    WARP_CONTRACTS.TOKENS,                    {                        "DeleteEntry": {                            "id": id                        }                    },                    txs.calculateFee(400000, gasPrice)                );                let txData = await statusChecker(outgoinxTxData.transactionHash);                if (txData.raw_log.indexOf('failed') !== -1) {                    return reject(new Error(txData.raw_log));                }                setTimeout(() => {                    setEditing(false);                    loadContractData(jsCyber);                    accept()                }, 300);            } catch (e) {                reject(e)            }        })    };    const editRow = async (id, name, ticker, denom, metadata, chain_id, logo) => {        return new Promise(async (accept, reject) => {            try {                const gasPrice = GasPrice.fromString('0.001boot');                try {                    const [{ address }] = await keplr.signer.getAccounts();                    let options = { "id": id, };                    if (name) {                        options['name'] = name;                    }                    if (logo) {                        let {cid} = await pushIpfsImage(logo);                        options['logo'] = cid;                    }                    if (chain_id) {                        options['chain_id'] = chain_id;                    }                    if (ticker) {                        options['ticker'] = ticker;                    }                    if (denom) {                        options['denom'] = denom;                    }                    if (metadata) {                        options['metadata'] = metadata;                    }                    const outgoinxTxData = await keplr.execute(                        address,                        WARP_CONTRACTS.TOKENS,                        {                            "UpdateEntry": options                        },                        txs.calculateFee(400000, gasPrice)                    );                    let txData = await statusChecker(outgoinxTxData.transactionHash);                    if (txData.raw_log.indexOf('failed') !== -1) {                        return reject(new Error(txData.raw_log));                    }                    setTimeout(() => {                        loadContractData(jsCyber);                        setEditing(false);                        accept();                    }, 300);                } catch (e) {                    reject(e);                }            } catch (e) {                reject(e);            }        })    };    const addRow = async (name, ticker, denom, metadata, chain_id, logo) => {        return new Promise(async (accept, reject) => {            try {                const { cid } = await pushIpfsImage(logo);                const gasPrice = GasPrice.fromString('0.001boot');                const [{ address }] = await keplr.signer.getAccounts();                try {                    const outgoinxTxData = await keplr.execute(                        address,                        WARP_CONTRACTS.TOKENS,                        {                            "NewEntry": {                                "name": name,                                "logo": cid,                                "chain_id": chain_id,                                "ticker": ticker,                                "denom": denom,                                "metadata": metadata,                            }                        },                        txs.calculateFee(400000, gasPrice)                    );                    let txData = await statusChecker(outgoinxTxData.transactionHash);                    if (txData.raw_log.indexOf('failed') !== -1) {                        return reject(new Error(txData.raw_log));                    }                    setTimeout(() => {                        loadContractData(jsCyber);                        setCreating(false);                        accept();                    }, 300);                } catch (e) {                    reject(e);                }            } catch (e) {                reject(e);            }        })    };    getItems();    useEffect(() => {        if (jsCyber === null) {            return;        }        loadNetworksData(jsCyber);    }, [jsCyber]);    let content;    content = (        <div style={{ width: "100%" }}>            <h1>Tokens</h1>            <div>                {editing ? (                    <div>                        <EditItemForm networks={networks} data={editing} onSelectLogo={onSelectLogo} editRow={editRow} onCancel={(e) => setEditing(false)}                                      onDelete={deleteRow}/>                    </div>                ) : (creating ? (                        <div>                            <AddItemForm networks={networks} addRow={addRow} onSelectLogo={onSelectLogo} onCancel={(e) => setCreating(false)}/>                        </div>                    ) : <div></div>                )                }            </div>            <div className={styles.containerWarpFieldsInputContainer}>                <h2>Available tokens</h2>                <ItemsList items={contractData} onEdit={(params) => setEditing(params)}/>                <input type="button" className="btn " value="Add new token" onClick={(e) => setCreating(true)}/>            </div>        </div>    );    return (        <>            <main className="block-body">                <Pane                    width="100%"                    display="flex"                    alignItems="center"                    flexDirection="column"                >                    {content}                </Pane>            </main>        </>    );}const mapStateToProps = (store) => {    return {        mobile: store.settings.mobile,        defaultAccount: store.pocket.defaultAccount,        ipfs: store.ipfs.ipfs,    };};export default connect(mapStateToProps)(WarpTokens);